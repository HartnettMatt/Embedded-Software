<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MH_Course_Project: src/Source_Files/i2c.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MH_Course_Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('i2c_8c.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">i2c.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Contains all the LETIMER driver functions.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;i2c.h&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a9914d2cf4afce64d4e8bdda003c34cc3"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8c.html#a9914d2cf4afce64d4e8bdda003c34cc3">i2c_ack</a> ()</td></tr>
<tr class="memdesc:a9914d2cf4afce64d4e8bdda003c34cc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function services the I2C ACK interrupt, and behaves based on the state of the I2C state machine.  <a href="i2c_8c.html#a9914d2cf4afce64d4e8bdda003c34cc3">More...</a><br /></td></tr>
<tr class="separator:a9914d2cf4afce64d4e8bdda003c34cc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebd0fd7ba10bcb67471231fa231f878e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8c.html#aebd0fd7ba10bcb67471231fa231f878e">i2c_nack</a> ()</td></tr>
<tr class="memdesc:aebd0fd7ba10bcb67471231fa231f878e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function services the I2C NACK interrupt, and behaves based on the state of the I2C state machine.  <a href="i2c_8c.html#aebd0fd7ba10bcb67471231fa231f878e">More...</a><br /></td></tr>
<tr class="separator:aebd0fd7ba10bcb67471231fa231f878e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6e3096bf98a91ca2a30f6bf9f997623"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8c.html#ae6e3096bf98a91ca2a30f6bf9f997623">i2c_rxdatav</a> ()</td></tr>
<tr class="memdesc:ae6e3096bf98a91ca2a30f6bf9f997623"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function services the I2C RXDATAV interrupt, and behaves based on the state of the I2C state machine.  <a href="i2c_8c.html#ae6e3096bf98a91ca2a30f6bf9f997623">More...</a><br /></td></tr>
<tr class="separator:ae6e3096bf98a91ca2a30f6bf9f997623"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa55303c11de14451333d35683e8627e4"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8c.html#aa55303c11de14451333d35683e8627e4">i2c_mstop</a> ()</td></tr>
<tr class="memdesc:aa55303c11de14451333d35683e8627e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function services the I2C MSTOP interrupt, and behaves based on the state of the I2C state machine.  <a href="i2c_8c.html#aa55303c11de14451333d35683e8627e4">More...</a><br /></td></tr>
<tr class="separator:aa55303c11de14451333d35683e8627e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d74e3a730c761f8adad646b4c696df6"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8c.html#a3d74e3a730c761f8adad646b4c696df6">i2c_bus_reset</a> (I2C_TypeDef *i2c)</td></tr>
<tr class="memdesc:a3d74e3a730c761f8adad646b4c696df6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function resets the I2C bus for either the I2C0 or I2C1 peripheral.  <a href="i2c_8c.html#a3d74e3a730c761f8adad646b4c696df6">More...</a><br /></td></tr>
<tr class="separator:a3d74e3a730c761f8adad646b4c696df6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd501191443ae27fa7ab059461676249"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8c.html#afd501191443ae27fa7ab059461676249">i2c_open</a> (I2C_TypeDef *i2c, <a class="el" href="struct_i2_c___o_p_e_n___s_t_r_u_c_t.html">I2C_OPEN_STRUCT</a> *i2c_setup)</td></tr>
<tr class="memdesc:afd501191443ae27fa7ab059461676249"><td class="mdescLeft">&#160;</td><td class="mdescRight">Driver to open an set an I2C peripheral.  <a href="i2c_8c.html#afd501191443ae27fa7ab059461676249">More...</a><br /></td></tr>
<tr class="separator:afd501191443ae27fa7ab059461676249"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdf301577035a16114db860813decd10"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8c.html#abdf301577035a16114db860813decd10">i2c_start</a> (uint32_t slave_add, uint32_t cmd, uint32_t *read_data, I2C_TypeDef *i2c, uint32_t si7021_read_cb)</td></tr>
<tr class="memdesc:abdf301577035a16114db860813decd10"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function begins the operation of the I2C state machine.  <a href="i2c_8c.html#abdf301577035a16114db860813decd10">More...</a><br /></td></tr>
<tr class="separator:abdf301577035a16114db860813decd10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e817e99d2a59e5f48e4ff0c79e7eef5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8c.html#a8e817e99d2a59e5f48e4ff0c79e7eef5">I2C0_IRQHandler</a> (void)</td></tr>
<tr class="memdesc:a8e817e99d2a59e5f48e4ff0c79e7eef5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is the interrupt handler for the I2C peripheral.  <a href="i2c_8c.html#a8e817e99d2a59e5f48e4ff0c79e7eef5">More...</a><br /></td></tr>
<tr class="separator:a8e817e99d2a59e5f48e4ff0c79e7eef5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a2babca2deb829a8d3b6c385003745c7a"><td class="memItemLeft" align="right" valign="top"><a id="a2babca2deb829a8d3b6c385003745c7a"></a>
static <a class="el" href="struct_i2_c___s_t_a_t_e___m_a_c_h_i_n_e.html">I2C_STATE_MACHINE</a>&#160;</td><td class="memItemRight" valign="bottom"><b>i2c_sm</b></td></tr>
<tr class="separator:a2babca2deb829a8d3b6c385003745c7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7c0c7abdee8faa6f35a8fb850dadbb3"><td class="memItemLeft" align="right" valign="top"><a id="af7c0c7abdee8faa6f35a8fb850dadbb3"></a>
static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>event</b></td></tr>
<tr class="separator:af7c0c7abdee8faa6f35a8fb850dadbb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Contains all the LETIMER driver functions. </p>
<dl class="section author"><dt>Author</dt><dd>Matt Hartnett </dd></dl>
<dl class="section date"><dt>Date</dt><dd>December 4th, 2020 </dd></dl>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a8e817e99d2a59e5f48e4ff0c79e7eef5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e817e99d2a59e5f48e4ff0c79e7eef5">&#9670;&nbsp;</a></span>I2C0_IRQHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2C0_IRQHandler </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is the interrupt handler for the I2C peripheral. </p>
<p>Upon receiving an interrupt, this function first clears the flag register of that interrupt while preserving any other interrupts waiting to be serviced. It then calls the service routine for any of the enabled I2C interrupts that need to be serviced.</p>
<dl class="section note"><dt>Note</dt><dd>This function does not alter or service any interrupts not allowed within the I2C interrupt enable (IEN) register. </dd></dl>

</div>
</div>
<a id="a9914d2cf4afce64d4e8bdda003c34cc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9914d2cf4afce64d4e8bdda003c34cc3">&#9670;&nbsp;</a></span>i2c_ack()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void i2c_ack </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function services the I2C ACK interrupt, and behaves based on the state of the I2C state machine. </p>
<p>If the ACK interrupt is expected for a given state, then this function will handle everything that needs to be done within the state machine until the next interrupt is received. If an ACK is received while in a state that does not expect an ACK, this function will get caught in an EFM_ASSERT.</p>
<dl class="section note"><dt>Note</dt><dd>This function sends bus commands and advances the state machine based on the current state. </dd></dl>

</div>
</div>
<a id="a3d74e3a730c761f8adad646b4c696df6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d74e3a730c761f8adad646b4c696df6">&#9670;&nbsp;</a></span>i2c_bus_reset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void i2c_bus_reset </td>
          <td>(</td>
          <td class="paramtype">I2C_TypeDef *&#160;</td>
          <td class="paramname"><em>i2c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function resets the I2C bus for either the I2C0 or I2C1 peripheral. </p>
<p>This routine is meant to ensure that the I2C bus is cleared, along with the I2C interrupt flag register and the CMD register.</p>
<dl class="section note"><dt>Note</dt><dd>This function is only meant to be used within the I2C.c routines, primarily when the peripheral is being opened in <a class="el" href="i2c_8c.html#afd501191443ae27fa7ab059461676249" title="Driver to open an set an I2C peripheral.">i2c_open()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the base peripheral address of the i2c peripheral being reset </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa55303c11de14451333d35683e8627e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa55303c11de14451333d35683e8627e4">&#9670;&nbsp;</a></span>i2c_mstop()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void i2c_mstop </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function services the I2C MSTOP interrupt, and behaves based on the state of the I2C state machine. </p>
<p>If the MSTOP interrupt is expected for a given state, then this function will handle everything that needs to be done within the state machine until the next interrupt is received. If an MSTOP is received while in a state that does not expect an MSTOP, this function will get caught in an EFM_ASSERT.</p>
<dl class="section note"><dt>Note</dt><dd>This function sends bus commands and advances the state machine based on the current state. </dd></dl>

</div>
</div>
<a id="aebd0fd7ba10bcb67471231fa231f878e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebd0fd7ba10bcb67471231fa231f878e">&#9670;&nbsp;</a></span>i2c_nack()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void i2c_nack </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function services the I2C NACK interrupt, and behaves based on the state of the I2C state machine. </p>
<p>If the NACK interrupt is expected for a given state, then this function will handle everything that needs to be done within the state machine until the next interrupt is received. If an NACK is received while in a state that does not expect an NACK, this function will get caught in an EFM_ASSERT.</p>
<dl class="section note"><dt>Note</dt><dd>This function sends bus commands and advances the state machine based on the current state. </dd></dl>

</div>
</div>
<a id="afd501191443ae27fa7ab059461676249"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd501191443ae27fa7ab059461676249">&#9670;&nbsp;</a></span>i2c_open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void i2c_open </td>
          <td>(</td>
          <td class="paramtype">I2C_TypeDef *&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_i2_c___o_p_e_n___s_t_r_u_c_t.html">I2C_OPEN_STRUCT</a> *&#160;</td>
          <td class="paramname"><em>i2c_setup</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Driver to open an set an I2C peripheral. </p>
<p>This routine is a low level driver. The application code calls this function to open one of the I2C peripherals, and the values used in the initialization of the I2C peripheral are provided by the application layer.</p>
<dl class="section note"><dt>Note</dt><dd>This function is normally called once to initialize the peripheral and the function <a class="el" href="i2c_8c.html#abdf301577035a16114db860813decd10" title="This function begins the operation of the I2C state machine.">i2c_start()</a> is called to turn-on or turn-off the i2c operation.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the base peripheral address of the i2c peripheral being opened</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c_setup</td><td>This is the STRUCT that the calling routine will use to set the parameters for operation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae6e3096bf98a91ca2a30f6bf9f997623"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6e3096bf98a91ca2a30f6bf9f997623">&#9670;&nbsp;</a></span>i2c_rxdatav()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void i2c_rxdatav </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function services the I2C RXDATAV interrupt, and behaves based on the state of the I2C state machine. </p>
<p>If the RXDATAV interrupt is expected for a given state, then this function will handle everything that needs to be done within the state machine until the next interrupt is received. If an RXDATAV is received while in a state that does not expect an RXDATAV, this function will get caught in an EFM_ASSERT.</p>
<dl class="section note"><dt>Note</dt><dd>This function sends bus commands and advances the state machine based on the current state. </dd></dl>

</div>
</div>
<a id="abdf301577035a16114db860813decd10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdf301577035a16114db860813decd10">&#9670;&nbsp;</a></span>i2c_start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void i2c_start </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>slave_add</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>read_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I2C_TypeDef *&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>si7021_read_cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function begins the operation of the I2C state machine. </p>
<p>Begins by ensuring that the I2C state machine is not busy with another operation, and upon confirmation of availability, blocks the appropriate energy mode, and then begins the state machine with the values passed through the function call.</p>
<dl class="section note"><dt>Note</dt><dd>Requires that the I2C bus in not in use when called or this function will be caught in an EFM_ASSERT.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">slave_add</td><td>Pointer to the base peripheral address of the i2c slave device.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>The command being passed into the I2C slave.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">read_data</td><td>A pointer to the data that is read off of the I2C bus</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the base peripheral address of the i2c peripheral being opened</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">si7021_read_cb</td><td>The scheduler event value, which is required to clear the scheduler when the I2C state machine has terminated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_2855980263c52be09af3085e80bd06a7.html">Source_Files</a></li><li class="navelem"><a class="el" href="i2c_8c.html">i2c.c</a></li>
    <li class="footer">Generated by <a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20 </li>
  </ul>
</div>
</body>
</html>
