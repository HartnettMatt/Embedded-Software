<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MH_I2C_Lab: src/Source_Files/i2c.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MH_I2C_Lab
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('i2c_8c.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">i2c.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Contains all the LETIMER driver functions.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;i2c.h&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:afd501191443ae27fa7ab059461676249"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8c.html#afd501191443ae27fa7ab059461676249">i2c_open</a> (I2C_TypeDef *i2c, <a class="el" href="struct_i2_c___o_p_e_n___s_t_r_u_c_t.html">I2C_OPEN_STRUCT</a> *i2c_setup)</td></tr>
<tr class="memdesc:afd501191443ae27fa7ab059461676249"><td class="mdescLeft">&#160;</td><td class="mdescRight">Driver to open an set an I2C peripheral.  <a href="i2c_8c.html#afd501191443ae27fa7ab059461676249">More...</a><br /></td></tr>
<tr class="separator:afd501191443ae27fa7ab059461676249"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdf301577035a16114db860813decd10"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8c.html#abdf301577035a16114db860813decd10">i2c_start</a> (uint32_t slave_add, uint32_t cmd, uint32_t *read_data, I2C_TypeDef *i2c, uint32_t si7021_read_cb)</td></tr>
<tr class="memdesc:abdf301577035a16114db860813decd10"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function begins the operation of the I2C state machine.  <a href="i2c_8c.html#abdf301577035a16114db860813decd10">More...</a><br /></td></tr>
<tr class="separator:abdf301577035a16114db860813decd10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e817e99d2a59e5f48e4ff0c79e7eef5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8c.html#a8e817e99d2a59e5f48e4ff0c79e7eef5">I2C0_IRQHandler</a> (void)</td></tr>
<tr class="memdesc:a8e817e99d2a59e5f48e4ff0c79e7eef5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is the interrupt handler for the I2C peripheral.  <a href="i2c_8c.html#a8e817e99d2a59e5f48e4ff0c79e7eef5">More...</a><br /></td></tr>
<tr class="separator:a8e817e99d2a59e5f48e4ff0c79e7eef5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92bf7706d4dfd41c7a2a66e652ea7708"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8c.html#a92bf7706d4dfd41c7a2a66e652ea7708">i2c_ack</a> ()</td></tr>
<tr class="memdesc:a92bf7706d4dfd41c7a2a66e652ea7708"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function services the I2C ACK interrupt, and behaves based on the state of the I2C state machine.  <a href="i2c_8c.html#a92bf7706d4dfd41c7a2a66e652ea7708">More...</a><br /></td></tr>
<tr class="separator:a92bf7706d4dfd41c7a2a66e652ea7708"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9947da66b763b4b38c28d5ee44fb0a2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8c.html#ae9947da66b763b4b38c28d5ee44fb0a2">i2c_nack</a> ()</td></tr>
<tr class="memdesc:ae9947da66b763b4b38c28d5ee44fb0a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function services the I2C NACK interrupt, and behaves based on the state of the I2C state machine.  <a href="i2c_8c.html#ae9947da66b763b4b38c28d5ee44fb0a2">More...</a><br /></td></tr>
<tr class="separator:ae9947da66b763b4b38c28d5ee44fb0a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab2b919e784f8bea20ed0c3a84bb714d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8c.html#aab2b919e784f8bea20ed0c3a84bb714d">i2c_rxdatav</a> ()</td></tr>
<tr class="memdesc:aab2b919e784f8bea20ed0c3a84bb714d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function services the I2C RXDATAV interrupt, and behaves based on the state of the I2C state machine.  <a href="i2c_8c.html#aab2b919e784f8bea20ed0c3a84bb714d">More...</a><br /></td></tr>
<tr class="separator:aab2b919e784f8bea20ed0c3a84bb714d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2b2f9c8c28bfa37a43b41ba9f0a29e5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8c.html#ab2b2f9c8c28bfa37a43b41ba9f0a29e5">i2c_mstop</a> ()</td></tr>
<tr class="memdesc:ab2b2f9c8c28bfa37a43b41ba9f0a29e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function services the I2C MSTOP interrupt, and behaves based on the state of the I2C state machine.  <a href="i2c_8c.html#ab2b2f9c8c28bfa37a43b41ba9f0a29e5">More...</a><br /></td></tr>
<tr class="separator:ab2b2f9c8c28bfa37a43b41ba9f0a29e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Contains all the LETIMER driver functions. </p>
<dl class="section author"><dt>Author</dt><dd>Matt Hartnett </dd></dl>
<dl class="section date"><dt>Date</dt><dd>October 18th, 2020 </dd></dl>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a8e817e99d2a59e5f48e4ff0c79e7eef5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e817e99d2a59e5f48e4ff0c79e7eef5">&#9670;&nbsp;</a></span>I2C0_IRQHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void I2C0_IRQHandler </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is the interrupt handler for the I2C peripheral. </p>
<p>Upon receiving an interrupt, this function first clears the flag register of that interrupt while preserving any other interrupts waiting to be serviced. It then calls the service routine for any of the enabled I2C interrupts that need to be serviced.</p>
<dl class="section note"><dt>Note</dt><dd>This function does not alter or service any interrupts not allowed within the I2C interrupt enable (IEN) register. </dd></dl>

</div>
</div>
<a id="a92bf7706d4dfd41c7a2a66e652ea7708"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92bf7706d4dfd41c7a2a66e652ea7708">&#9670;&nbsp;</a></span>i2c_ack()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void i2c_ack </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function services the I2C ACK interrupt, and behaves based on the state of the I2C state machine. </p>
<p>If the ACK interrupt is expected for a given state, then this function will handle everything that needs to be done within the state machine until the next interrupt is received. If an ACK is received while in a state that does not expect an ACK, this function will get caught in an EFM_ASSERT.</p>
<dl class="section note"><dt>Note</dt><dd>This function sends bus commands and advances the state machine based on the current state. </dd></dl>

</div>
</div>
<a id="ab2b2f9c8c28bfa37a43b41ba9f0a29e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2b2f9c8c28bfa37a43b41ba9f0a29e5">&#9670;&nbsp;</a></span>i2c_mstop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void i2c_mstop </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function services the I2C MSTOP interrupt, and behaves based on the state of the I2C state machine. </p>
<p>If the MSTOP interrupt is expected for a given state, then this function will handle everything that needs to be done within the state machine until the next interrupt is received. If an MSTOP is received while in a state that does not expect an MSTOP, this function will get caught in an EFM_ASSERT.</p>
<dl class="section note"><dt>Note</dt><dd>This function sends bus commands and advances the state machine based on the current state. </dd></dl>

</div>
</div>
<a id="ae9947da66b763b4b38c28d5ee44fb0a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9947da66b763b4b38c28d5ee44fb0a2">&#9670;&nbsp;</a></span>i2c_nack()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void i2c_nack </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function services the I2C NACK interrupt, and behaves based on the state of the I2C state machine. </p>
<p>If the NACK interrupt is expected for a given state, then this function will handle everything that needs to be done within the state machine until the next interrupt is received. If an NACK is received while in a state that does not expect an NACK, this function will get caught in an EFM_ASSERT.</p>
<dl class="section note"><dt>Note</dt><dd>This function sends bus commands and advances the state machine based on the current state. </dd></dl>

</div>
</div>
<a id="afd501191443ae27fa7ab059461676249"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd501191443ae27fa7ab059461676249">&#9670;&nbsp;</a></span>i2c_open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void i2c_open </td>
          <td>(</td>
          <td class="paramtype">I2C_TypeDef *&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_i2_c___o_p_e_n___s_t_r_u_c_t.html">I2C_OPEN_STRUCT</a> *&#160;</td>
          <td class="paramname"><em>i2c_setup</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Driver to open an set an I2C peripheral. </p>
<p>This routine is a low level driver. The application code calls this function to open one of the I2C peripherals, and the values used in the initialization of the I2C peripheral are provided by the application layer.</p>
<dl class="section note"><dt>Note</dt><dd>This function is normally called once to initialize the peripheral and the function <a class="el" href="i2c_8c.html#abdf301577035a16114db860813decd10" title="This function begins the operation of the I2C state machine.">i2c_start()</a> is called to turn-on or turn-off the i2c operation.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the base peripheral address of the i2c peripheral being opened</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c_setup</td><td>This is the STRUCT that the calling routine will use to set the parameters for operation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aab2b919e784f8bea20ed0c3a84bb714d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab2b919e784f8bea20ed0c3a84bb714d">&#9670;&nbsp;</a></span>i2c_rxdatav()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void i2c_rxdatav </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function services the I2C RXDATAV interrupt, and behaves based on the state of the I2C state machine. </p>
<p>If the RXDATAV interrupt is expected for a given state, then this function will handle everything that needs to be done within the state machine until the next interrupt is received. If an RXDATAV is received while in a state that does not expect an RXDATAV, this function will get caught in an EFM_ASSERT.</p>
<dl class="section note"><dt>Note</dt><dd>This function sends bus commands and advances the state machine based on the current state. </dd></dl>

</div>
</div>
<a id="abdf301577035a16114db860813decd10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdf301577035a16114db860813decd10">&#9670;&nbsp;</a></span>i2c_start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void i2c_start </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>slave_add</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>read_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I2C_TypeDef *&#160;</td>
          <td class="paramname"><em>i2c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>si7021_read_cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function begins the operation of the I2C state machine. </p>
<p>Begins by ensuring that the I2C state machine is not busy with another operation, and upon confirmation of availability, blocks the appropriate energy mode, and then begins the state machine with the values passed through the function call.</p>
<dl class="section note"><dt>Note</dt><dd>Requires that the I2C bus in not in use when called or this function will be caught in an EFM_ASSERT.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">slave_add</td><td>Pointer to the base peripheral address of the i2c slave device.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>The command being passed into the I2C slave.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">read_data</td><td>A pointer to the data that is read off of the I2C bus</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">i2c</td><td>Pointer to the base peripheral address of the i2c peripheral being opened</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">si7021_read_cb</td><td>The scheduler event value, which is required to clear the scheduler when the I2C state machine has terminated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_2855980263c52be09af3085e80bd06a7.html">Source_Files</a></li><li class="navelem"><a class="el" href="i2c_8c.html">i2c.c</a></li>
    <li class="footer">Generated by <a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.20 </li>
  </ul>
</div>
</body>
</html>
